---
layout: post
title:  "[SQL]SQL첫걸음 SELECT문"
date:   2021-06-25 00:00:00 +0700
categories: [SQL]
---

***이 글은 ORACLE SQL을 기준으로 작성한 쿼리입니다.***

>SELECT문의 기본적인 테이블 조회

```SQL
SELECT * FROM 테이블명;
```

>테이블 속성 조회

```SQL
DESC 테이블명;
```



```SQL
SELECT * FROM 테이블명 WHERE 열 IS NULL;
```

SELECT * FROM emp WHERE COMM IS NOT NULL;
-- COMM 열에 NULL이 아닌 행 검색

SELECT * FROM emp WHERE DEPTNO <> 10;
-- DEPTNO 열에 10이 아닌 행 검색

SELECT * FROM emp WHERE DEPTNO = 10;
-- DEPTNO 열에 10이 맞는 행 검색

SELECT * FROM emp WHERE DEPTNO <> 10 OR JOB <> 'MANAGER';
-- DEPTNO 열에 10이 아닌 행이 아니거나 JOB 열에 'MANAGER' 행이 아닌 행을 검색

SELECT * FROM emp WHERE DEPTNO = 10 OR DEPTNO = 30;

SELECT * FROM emp WHERE DEPTNO=10 OR DEPTNO=20 AND JOB='MANAGER' OR JOB='ANALYST';
-- AND는 OR보다 우선 순위가 높음
-- [DEPTNO열이 10이다] 또는 [DEPTNO열이 20 이며 JOB열이 "MANAGER"이다] 또는 [JOB열이 "ANALYST"이다]

SELECT * FROM emp WHERE (DEPTNO=10 OR DEPTNO=20) AND (JOB='MANAGER' OR JOB='ANALYST');

SELECT * FROM emp WHERE NOT(DEPTNO<>10 OR JOB<>'MANAGER');

SELECT * FROM emp WHERE ename LIKE 'S%';
-- ENAME 열에 S로 시작하는 문자열 검색

SELECT * FROM emp WHERE ename LIKE '%N%';

SELECT * FROM emp WHERE ENAME LIKE '%\%%';
-- %를 문자로 찾고싶을때는 \%로 검색하면 된다.

SELECT * FROM emp WHERE ROWNUM <= 3;

SELECT *, empno*deptno FROM emp;
-- 오라클에서는 *해서 사용 못함

SELECT empno, deptno, empno*deptno AS AMOUNT FROM emp;

SELECT empno, deptno, empno+deptno AS amount FROM emp ORDER BY deptno ASC;

SELECT empno, deptno, ROUND(empno/deptno) AS amount FROM emp ORDER BY deptno ASC;
-- ROUND로 감싸면 반올림 가능

SELECT ROUND(empno/deptno, 1) AS amount FROM emp ORDER BY amount ASC;

SELECT ROUND(empno/deptno, -2) AS amount FROM emp ORDER BY amount ASC;

SELECT CONCAT(ename, deptno) AS string FROM emp;

SELECT SUBSTR(ename, 1, 3) AS substring FROM emp;

SELECT empno, CURRENT_TIMESTAMP FROM emp;

SELECT current_date + (INTERVAL '1' DAY) FROM emp;

SELECT current_date + INTERVAL '1' DAY FROM emp;

SELECT comm,
CASE WHEN comm IS NULL THEN 0
     ELSE comm
     END "comm(null=0)" FROM emp;
-- comm 열에 NULL값이 있을때 THEN으로 넘어가 0으로 값을 반환, NULL 없을때는 그냥 END! 열 표시는 "comm(null=0)"

SELECT comm, COALESCE(comm, 0) FROM emp;
-- comm 열이 NULL이 아니면 comm 값을 그대로 출력하고, 그렇지 않으면(comm이 NULL이면) 0을 출력

SELECT deptno AS "인코드",
CASE WHEN deptno = 10 THEN '십'
     WHEN deptno = 20 THEN '이십'
     WHEN deptno = 30 THEN '삼십'
     ELSE '미지정'
END AS "decode" FROM emp;

SELECT deptno AS "인코드",
CASE deptno --case 옆에 우선 지정하고 단순하게 쿼리 작성 가능
    WHEN 10 THEN '십'
    WHEN 20 THEN '이십'
    WHEN 30 THEN '삼십'
    ELSE '미지정'
END AS "디코드" FROM emp;

SELECT comm AS "INCODE",
CASE
    WHEN comm = 300 THEN '삼백'
    WHEN comm = 500 THEN '오백'
    WHEN comm IS NULL THEN '데이터 없음'
    ELSE '미지정'
END AS "DECODE" FROM emp;

SELECT * FROM emp WHERE ename LIKE '%S%' AND hiredate BETWEEN '80/12/17' AND '82/01/23';
--

/* INSERT : START */
INSERT INTO contacts(first_name, last_name, email, phone, customer_id) VALUES('han', 'moony', '111@2222', NULL, NULL);

/* UPDATE : START */
UPDATE contacts SET phone = '+86 10 012 3839' WHERE contact_id = 320;

SELECT COUNT(ALL region_id), COUNT(DISTINCT region_id) FROM COUNTRIES;
-- 중복을 제거 한 뒤 개수 구하기

SELECT SUM(region_id) FROM countries;
-- region_id열의 행들을 총 합하여 출력
-- AVG 평균, MIN 최솟값, MAX 최댓값

SELECT AVG(CASE WHEN region_id IS NULL THEN 0 ELSE region_id END) AS avgnull FROM countries;
-- 평균값을 계산할때 null값이 있을 경우 null을 제외하고 계산하는데 위 방법은 null을 0으로 변환 후 계산하는 방법이다.

SELECT region_id FROM countries GROUP BY region_id;

SELECT country_id, COUNT(country_id), SUM(region_id) FROM countries GROUP BY country_id;

SELECT customer_id, COUNT(customer_id), SUM(credit_limit) FROM customers GROUP BY customer_id;

SELECT status, COUNT(status) FROM orders GROUP BY status HAVING status LIKE '%P%' OR status LIKE '%p%';

SELECT status, COUNT(status), SUM(salesman_id) FROM orders GROUP BY status ORDER BY SUM(salesman_id) DESC;

SELECT MIN(salesman_id) FROM ORDERS;

SELECT * FROM orders WHERE salesman_id = 54;

DELETE FROM orders WHERE salesman_id = (SELECT MIN(salesman_id) FROM orders);

SELECT
    (SELECT COUNT(*) FROM ORDERS) AS sel1,
    (SELECT COUNT(*) FROM PRODUCTS) AS sel2 FROM DUAL;
